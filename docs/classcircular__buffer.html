<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cpp-headers: circular_buffer&lt; T, SIZE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cpp-headers
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcircular__buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">circular_buffer&lt; T, SIZE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in constant time.  
 <a href="classcircular__buffer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="circular__buffer_8h_source.html">circular_buffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7f98db9a4a35f2f60f4cea06ff0e9858"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a7f98db9a4a35f2f60f4cea06ff0e9858">value_type</a> = T</td></tr>
<tr class="separator:a7f98db9a4a35f2f60f4cea06ff0e9858"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa72634c61ba1c43cb1949cb1eb1d265e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#aa72634c61ba1c43cb1949cb1eb1d265e">circular_buffer</a> () noexcept=default</td></tr>
<tr class="memdesc:aa72634c61ba1c43cb1949cb1eb1d265e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initialising an empty <a class="el" href="classcircular__buffer.html" title="Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in c...">circular_buffer</a>.  <a href="#aa72634c61ba1c43cb1949cb1eb1d265e">More...</a><br /></td></tr>
<tr class="separator:aa72634c61ba1c43cb1949cb1eb1d265e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa459dd8e8e39b81e83eea3848e78bf04"><td class="memTemplParams" colspan="2">template&lt;typename... ARGS&gt; </td></tr>
<tr class="memitem:aa459dd8e8e39b81e83eea3848e78bf04"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#aa459dd8e8e39b81e83eea3848e78bf04">circular_buffer</a> (ARGS &amp;&amp;... args) noexcept</td></tr>
<tr class="memdesc:aa459dd8e8e39b81e83eea3848e78bf04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor, initialising the <a class="el" href="classcircular__buffer.html" title="Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in c...">circular_buffer</a>. Note: The first argument will be the first element inserted into the buffer (i.e. accessible with <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> or <code>at(0)</code>), the last argument will be the last element inserted (i.e. accessible with <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> or <code>at(<a class="el" href="classcircular__buffer.html#a11e64618f8e399b6b8b0bd08246c0578" title="Retrieves the current number of elements in the buffer. ">len()</a>-1)</code>).  <a href="#aa459dd8e8e39b81e83eea3848e78bf04">More...</a><br /></td></tr>
<tr class="separator:aa459dd8e8e39b81e83eea3848e78bf04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f53305705beefdcecca1dfd50a81f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a227f53305705beefdcecca1dfd50a81f">~circular_buffer</a> ()=default</td></tr>
<tr class="memdesc:a227f53305705beefdcecca1dfd50a81f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a227f53305705beefdcecca1dfd50a81f">More...</a><br /></td></tr>
<tr class="separator:a227f53305705beefdcecca1dfd50a81f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d47b24325cda58fb4f30b4986a72eec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a4d47b24325cda58fb4f30b4986a72eec">full</a> () const noexcept</td></tr>
<tr class="memdesc:a4d47b24325cda58fb4f30b4986a72eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the buffer is full. When full the buffer will insert new elements over the oldest.  <a href="#a4d47b24325cda58fb4f30b4986a72eec">More...</a><br /></td></tr>
<tr class="separator:a4d47b24325cda58fb4f30b4986a72eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975ff5109d2aa732ba479fcac22424db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a975ff5109d2aa732ba479fcac22424db">empty</a> () const noexcept</td></tr>
<tr class="memdesc:a975ff5109d2aa732ba479fcac22424db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not the buffer is empty.  <a href="#a975ff5109d2aa732ba479fcac22424db">More...</a><br /></td></tr>
<tr class="separator:a975ff5109d2aa732ba479fcac22424db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e64618f8e399b6b8b0bd08246c0578"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a11e64618f8e399b6b8b0bd08246c0578">len</a> () const noexcept</td></tr>
<tr class="memdesc:a11e64618f8e399b6b8b0bd08246c0578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current number of elements in the buffer.  <a href="#a11e64618f8e399b6b8b0bd08246c0578">More...</a><br /></td></tr>
<tr class="separator:a11e64618f8e399b6b8b0bd08246c0578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a088f9e7cfc8692c8f8d865c8eafa3"><td class="memItemLeft" align="right" valign="top">constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a96a088f9e7cfc8692c8f8d865c8eafa3">capacity</a> () const noexcept</td></tr>
<tr class="memdesc:a96a088f9e7cfc8692c8f8d865c8eafa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the maximum number of elements the buffer can hold before it starts overwriting the oldest. This is always <code>SIZE - 1</code>.  <a href="#a96a088f9e7cfc8692c8f8d865c8eafa3">More...</a><br /></td></tr>
<tr class="separator:a96a088f9e7cfc8692c8f8d865c8eafa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af883b229e4b838ef979f1e91c3e04cd4"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#af883b229e4b838ef979f1e91c3e04cd4">at</a> (std::size_t pos) const noexcept(false)</td></tr>
<tr class="memdesc:af883b229e4b838ef979f1e91c3e04cd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0.  <a href="#af883b229e4b838ef979f1e91c3e04cd4">More...</a><br /></td></tr>
<tr class="separator:af883b229e4b838ef979f1e91c3e04cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dd44b3630b2ff7e91c558ae569319b"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#ab1dd44b3630b2ff7e91c558ae569319b">at</a> (std::size_t pos) noexcept(false)</td></tr>
<tr class="memdesc:ab1dd44b3630b2ff7e91c558ae569319b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0.  <a href="#ab1dd44b3630b2ff7e91c558ae569319b">More...</a><br /></td></tr>
<tr class="separator:ab1dd44b3630b2ff7e91c558ae569319b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e5e167ea4529035c70defbe11089ec"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#ae6e5e167ea4529035c70defbe11089ec">operator[]</a> (std::size_t pos) const noexcept</td></tr>
<tr class="memdesc:ae6e5e167ea4529035c70defbe11089ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. This operation does not perform bounds checking, accessing an uninitialised element causes undefined behaviour.  <a href="#ae6e5e167ea4529035c70defbe11089ec">More...</a><br /></td></tr>
<tr class="separator:ae6e5e167ea4529035c70defbe11089ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b11bde27b687d4d7318438e29a77ef"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a89b11bde27b687d4d7318438e29a77ef">operator[]</a> (std::size_t pos) noexcept</td></tr>
<tr class="memdesc:a89b11bde27b687d4d7318438e29a77ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. This operation does not perform bounds checking, accessing an uninitialised element causes undefined behaviour.  <a href="#a89b11bde27b687d4d7318438e29a77ef">More...</a><br /></td></tr>
<tr class="separator:a89b11bde27b687d4d7318438e29a77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98cc246f1801a96a4086c92b6f842aa"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#ab98cc246f1801a96a4086c92b6f842aa">back</a> () const noexcept</td></tr>
<tr class="memdesc:ab98cc246f1801a96a4086c92b6f842aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last inserted (i.e. <em>newest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> on an empty buffer causes undefined behavior.  <a href="#ab98cc246f1801a96a4086c92b6f842aa">More...</a><br /></td></tr>
<tr class="separator:ab98cc246f1801a96a4086c92b6f842aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6b630e0ad19e64ed930317cf93593d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d">back</a> () noexcept</td></tr>
<tr class="memdesc:a5f6b630e0ad19e64ed930317cf93593d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the last inserted (i.e. <em>newest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> on an empty buffer causes undefined behavior.  <a href="#a5f6b630e0ad19e64ed930317cf93593d">More...</a><br /></td></tr>
<tr class="separator:a5f6b630e0ad19e64ed930317cf93593d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d4ab71e77b3f48fac024979792977"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a1f8d4ab71e77b3f48fac024979792977">front</a> () const noexcept</td></tr>
<tr class="memdesc:a1f8d4ab71e77b3f48fac024979792977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first inserted (i.e. <em>oldest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> on an empty buffer causes undefined behavior.  <a href="#a1f8d4ab71e77b3f48fac024979792977">More...</a><br /></td></tr>
<tr class="separator:a1f8d4ab71e77b3f48fac024979792977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d432f114bec19a0cb9950c65244f22c"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c">front</a> () noexcept</td></tr>
<tr class="memdesc:a8d432f114bec19a0cb9950c65244f22c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to the first inserted (i.e. <em>oldest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> on an empty buffer causes undefined behavior.  <a href="#a8d432f114bec19a0cb9950c65244f22c">More...</a><br /></td></tr>
<tr class="separator:a8d432f114bec19a0cb9950c65244f22c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1a957dcd4cb24f3576dff14070ddca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#aba1a957dcd4cb24f3576dff14070ddca">push_back</a> (const T &amp;item) noexcept</td></tr>
<tr class="memdesc:aba1a957dcd4cb24f3576dff14070ddca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies an item into the buffer, overwriting the oldest item if the buffer is full.  <a href="#aba1a957dcd4cb24f3576dff14070ddca">More...</a><br /></td></tr>
<tr class="separator:aba1a957dcd4cb24f3576dff14070ddca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb1e33459c036716f9460e5b612c0fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#aeeb1e33459c036716f9460e5b612c0fb">push_back</a> (T &amp;&amp;item) noexcept</td></tr>
<tr class="memdesc:aeeb1e33459c036716f9460e5b612c0fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves an item into the buffer, overwriting the oldest item if the buffer is full.  <a href="#aeeb1e33459c036716f9460e5b612c0fb">More...</a><br /></td></tr>
<tr class="separator:aeeb1e33459c036716f9460e5b612c0fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18304a8f6b8b3107b327d5a05baa57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a1f18304a8f6b8b3107b327d5a05baa57">pop_back</a> () noexcept</td></tr>
<tr class="memdesc:a1f18304a8f6b8b3107b327d5a05baa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the newest item from the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a1f18304a8f6b8b3107b327d5a05baa57" title="Removes the newest item from the buffer. Calling pop_back() on an empty buffer causes undefined behav...">pop_back()</a></code> on an empty buffer causes undefined behaviour.  <a href="#a1f18304a8f6b8b3107b327d5a05baa57">More...</a><br /></td></tr>
<tr class="separator:a1f18304a8f6b8b3107b327d5a05baa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1c351dd66a6f620869097f8093be1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a1f1c351dd66a6f620869097f8093be1d">pop_front</a> () noexcept</td></tr>
<tr class="memdesc:a1f1c351dd66a6f620869097f8093be1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the oldest item from the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a1f1c351dd66a6f620869097f8093be1d" title="Removes the oldest item from the buffer. Calling pop_front() on an empty buffer causes undefined beha...">pop_front()</a></code> on an empty buffer causes undefined behaviour.  <a href="#a1f1c351dd66a6f620869097f8093be1d">More...</a><br /></td></tr>
<tr class="separator:a1f1c351dd66a6f620869097f8093be1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2011d142037d8577c7149d4fdf9f462a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__buffer_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a2011d142037d8577c7149d4fdf9f462a">begin</a> () noexcept</td></tr>
<tr class="memdesc:a2011d142037d8577c7149d4fdf9f462a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to the beginning (i.e. front) of the buffer. If the buffer is empty the returned iterator will be equal to <code><a class="el" href="classcircular__buffer.html#aa48c6354a1f658f0cc1c82e671227352" title="Returns an iterable object to the element following the last element (i.e. back) of the buffer...">end()</a></code>.  <a href="#a2011d142037d8577c7149d4fdf9f462a">More...</a><br /></td></tr>
<tr class="separator:a2011d142037d8577c7149d4fdf9f462a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d2a9bc277b89fb7c3685ca08c9cc8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__buffer_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#a73d2a9bc277b89fb7c3685ca08c9cc8a">begin</a> () const noexcept</td></tr>
<tr class="memdesc:a73d2a9bc277b89fb7c3685ca08c9cc8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to the beginning (i.e. front) of the buffer. If the buffer is empty the returned iterator will be equal to <code><a class="el" href="classcircular__buffer.html#aa48c6354a1f658f0cc1c82e671227352" title="Returns an iterable object to the element following the last element (i.e. back) of the buffer...">end()</a></code>.  <a href="#a73d2a9bc277b89fb7c3685ca08c9cc8a">More...</a><br /></td></tr>
<tr class="separator:a73d2a9bc277b89fb7c3685ca08c9cc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48c6354a1f658f0cc1c82e671227352"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__buffer_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#aa48c6354a1f658f0cc1c82e671227352">end</a> () noexcept</td></tr>
<tr class="memdesc:aa48c6354a1f658f0cc1c82e671227352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to the element following the last element (i.e. back) of the buffer. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="#aa48c6354a1f658f0cc1c82e671227352">More...</a><br /></td></tr>
<tr class="separator:aa48c6354a1f658f0cc1c82e671227352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42e08ae615edd2a77f91dc3cef75bb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcircular__buffer_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcircular__buffer.html#ac42e08ae615edd2a77f91dc3cef75bb2">end</a> () const noexcept</td></tr>
<tr class="memdesc:ac42e08ae615edd2a77f91dc3cef75bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable object to the element following the last element (i.e. back) of the buffer. This element acts as a placeholder; attempting to access it results in undefined behavior.  <a href="#ac42e08ae615edd2a77f91dc3cef75bb2">More...</a><br /></td></tr>
<tr class="separator:ac42e08ae615edd2a77f91dc3cef75bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, std::size_t SIZE&gt;<br />
class circular_buffer&lt; T, SIZE &gt;</h3>

<p>Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in constant time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">T</td><td>The type stored in this buffer. Must have a default constructor. </td></tr>
    <tr><td class="paramname">SIZE</td><td>The number of elements to be stored in the buffer. One space in the buffer is always left empty, so ensure that this is accounted for when the SIZE is decided upon (i.e. <code>capacity = SIZE - 1</code>). SIZE must be &gt;= 1 (which would result in a buffer with no usable elements). </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7f98db9a4a35f2f60f4cea06ff0e9858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f98db9a4a35f2f60f4cea06ff0e9858">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::<a class="el" href="classcircular__buffer.html#a7f98db9a4a35f2f60f4cea06ff0e9858">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type this buffer stores. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa72634c61ba1c43cb1949cb1eb1d265e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa72634c61ba1c43cb1949cb1eb1d265e">&#9670;&nbsp;</a></span>circular_buffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::<a class="el" href="classcircular__buffer.html">circular_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, initialising an empty <a class="el" href="classcircular__buffer.html" title="Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in c...">circular_buffer</a>. </p>

</div>
</div>
<a id="aa459dd8e8e39b81e83eea3848e78bf04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa459dd8e8e39b81e83eea3848e78bf04">&#9670;&nbsp;</a></span>circular_buffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<div class="memtemplate">
template&lt;typename... ARGS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::<a class="el" href="classcircular__buffer.html">circular_buffer</a> </td>
          <td>(</td>
          <td class="paramtype">ARGS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor, initialising the <a class="el" href="classcircular__buffer.html" title="Fast implementation of a Circular Buffer. All operations on the Circular Buffer can be performed in c...">circular_buffer</a>. Note: The first argument will be the first element inserted into the buffer (i.e. accessible with <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> or <code>at(0)</code>), the last argument will be the last element inserted (i.e. accessible with <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> or <code>at(<a class="el" href="classcircular__buffer.html#a11e64618f8e399b6b8b0bd08246c0578" title="Retrieves the current number of elements in the buffer. ">len()</a>-1)</code>). </p>

</div>
</div>
<a id="a227f53305705beefdcecca1dfd50a81f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227f53305705beefdcecca1dfd50a81f">&#9670;&nbsp;</a></span>~circular_buffer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::~<a class="el" href="classcircular__buffer.html">circular_buffer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af883b229e4b838ef979f1e91c3e04cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af883b229e4b838ef979f1e91c3e04cd4">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index of the target element in the virtual 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the target element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the index is invalid (i.e. not <code>0 &lt;= index &lt; SIZE-1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__buffer.html#a89b11bde27b687d4d7318438e29a77ef" title="Treats the buffer like an array with indices [0,SIZE-1) and returns the item from the buffer located ...">operator[](std::size_t)</a> </dd></dl>

</div>
</div>
<a id="ab1dd44b3630b2ff7e91c558ae569319b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dd44b3630b2ff7e91c558ae569319b">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::at </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index of the target element in the virtual 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the target element. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the index is invalid (i.e. not <code>0 &lt;= index &lt; SIZE-1</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__buffer.html#a89b11bde27b687d4d7318438e29a77ef" title="Treats the buffer like an array with indices [0,SIZE-1) and returns the item from the buffer located ...">operator[](std::size_t)</a> </dd></dl>

</div>
</div>
<a id="ab98cc246f1801a96a4086c92b6f842aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98cc246f1801a96a4086c92b6f842aa">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last inserted (i.e. <em>newest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> on an empty buffer causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newest element in the buffer. </dd></dl>

</div>
</div>
<a id="a5f6b630e0ad19e64ed930317cf93593d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f6b630e0ad19e64ed930317cf93593d">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the last inserted (i.e. <em>newest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a5f6b630e0ad19e64ed930317cf93593d" title="Returns a reference to the last inserted (i.e. newest) element in the buffer. Calling back() on an em...">back()</a></code> on an empty buffer causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the newest element in the buffer. </dd></dl>

</div>
</div>
<a id="a2011d142037d8577c7149d4fdf9f462a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2011d142037d8577c7149d4fdf9f462a">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__buffer_1_1iterator.html">iterator</a> <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to the beginning (i.e. front) of the buffer. If the buffer is empty the returned iterator will be equal to <code><a class="el" href="classcircular__buffer.html#aa48c6354a1f658f0cc1c82e671227352" title="Returns an iterable object to the element following the last element (i.e. back) of the buffer...">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the front of the buffer. </dd></dl>

</div>
</div>
<a id="a73d2a9bc277b89fb7c3685ca08c9cc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d2a9bc277b89fb7c3685ca08c9cc8a">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__buffer_1_1const__iterator.html">const_iterator</a> <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to the beginning (i.e. front) of the buffer. If the buffer is empty the returned iterator will be equal to <code><a class="el" href="classcircular__buffer.html#aa48c6354a1f658f0cc1c82e671227352" title="Returns an iterable object to the element following the last element (i.e. back) of the buffer...">end()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the front of the buffer. </dd></dl>

</div>
</div>
<a id="a96a088f9e7cfc8692c8f8d865c8eafa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a088f9e7cfc8692c8f8d865c8eafa3">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the maximum number of elements the buffer can hold before it starts overwriting the oldest. This is always <code>SIZE - 1</code>. </p>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of unique elements this buffer can hold. </dd></dl>

</div>
</div>
<a id="a975ff5109d2aa732ba479fcac22424db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975ff5109d2aa732ba479fcac22424db">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the buffer is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>The state of the buffer. </dd></dl>

</div>
</div>
<a id="aa48c6354a1f658f0cc1c82e671227352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48c6354a1f658f0cc1c82e671227352">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__buffer_1_1iterator.html">iterator</a> <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to the element following the last element (i.e. back) of the buffer. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="ac42e08ae615edd2a77f91dc3cef75bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42e08ae615edd2a77f91dc3cef75bb2">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcircular__buffer_1_1const__iterator.html">const_iterator</a> <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an iterable object to the element following the last element (i.e. back) of the buffer. This element acts as a placeholder; attempting to access it results in undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Iterator to the element following the last element. </dd></dl>

</div>
</div>
<a id="a1f8d4ab71e77b3f48fac024979792977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8d4ab71e77b3f48fac024979792977">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first inserted (i.e. <em>oldest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> on an empty buffer causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the oldest element in the buffer. </dd></dl>

</div>
</div>
<a id="a8d432f114bec19a0cb9950c65244f22c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d432f114bec19a0cb9950c65244f22c">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a reference to the first inserted (i.e. <em>oldest</em>) element in the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a8d432f114bec19a0cb9950c65244f22c" title="Returns a reference to the first inserted (i.e. oldest) element in the buffer. Calling front() on an ...">front()</a></code> on an empty buffer causes undefined behavior. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the oldest element in the buffer. </dd></dl>

</div>
</div>
<a id="a4d47b24325cda58fb4f30b4986a72eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d47b24325cda58fb4f30b4986a72eec">&#9670;&nbsp;</a></span>full()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::full </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns whether or not the buffer is full. When full the buffer will insert new elements over the oldest. </p>
<dl class="section return"><dt>Returns</dt><dd>The state of the buffer. </dd></dl>

</div>
</div>
<a id="a11e64618f8e399b6b8b0bd08246c0578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e64618f8e399b6b8b0bd08246c0578">&#9670;&nbsp;</a></span>len()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::len </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the current number of elements in the buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of elements in the buffer. </dd></dl>

</div>
</div>
<a id="ae6e5e167ea4529035c70defbe11089ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e5e167ea4529035c70defbe11089ec">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. This operation does not perform bounds checking, accessing an uninitialised element causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index of the target element in the virtual 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the target element. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__buffer.html#ab1dd44b3630b2ff7e91c558ae569319b" title="Treats the buffer like an array with indices [0,SIZE-1) and returns the item from the buffer located ...">at(std::size_t)</a> </dd></dl>

</div>
</div>
<a id="a89b11bde27b687d4d7318438e29a77ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b11bde27b687d4d7318438e29a77ef">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Treats the buffer like an array with indices <code>[0,SIZE-1)</code> and returns the item from the buffer located at the given index. The <b>oldest</b> element will be available at index 0. This operation does not perform bounds checking, accessing an uninitialised element causes undefined behaviour. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index of the target element in the virtual 'array'. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the target element. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classcircular__buffer.html#ab1dd44b3630b2ff7e91c558ae569319b" title="Treats the buffer like an array with indices [0,SIZE-1) and returns the item from the buffer located ...">at(std::size_t)</a> </dd></dl>

</div>
</div>
<a id="a1f18304a8f6b8b3107b327d5a05baa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18304a8f6b8b3107b327d5a05baa57">&#9670;&nbsp;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the newest item from the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a1f18304a8f6b8b3107b327d5a05baa57" title="Removes the newest item from the buffer. Calling pop_back() on an empty buffer causes undefined behav...">pop_back()</a></code> on an empty buffer causes undefined behaviour. </p>

</div>
</div>
<a id="a1f1c351dd66a6f620869097f8093be1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1c351dd66a6f620869097f8093be1d">&#9670;&nbsp;</a></span>pop_front()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes the oldest item from the buffer. Calling <code><a class="el" href="classcircular__buffer.html#a1f1c351dd66a6f620869097f8093be1d" title="Removes the oldest item from the buffer. Calling pop_front() on an empty buffer causes undefined beha...">pop_front()</a></code> on an empty buffer causes undefined behaviour. </p>

</div>
</div>
<a id="aba1a957dcd4cb24f3576dff14070ddca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1a957dcd4cb24f3576dff14070ddca">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies an item into the buffer, overwriting the oldest item if the buffer is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to copy into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeb1e33459c036716f9460e5b612c0fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb1e33459c036716f9460e5b612c0fb">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, std::size_t SIZE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcircular__buffer.html">circular_buffer</a>&lt; T, SIZE &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves an item into the buffer, overwriting the oldest item if the buffer is full. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>The item to move into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="circular__buffer_8h_source.html">circular_buffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
